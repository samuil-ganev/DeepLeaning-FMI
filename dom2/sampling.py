#############################################################################
### Търсене и извличане на информация. Приложение на дълбоко машинно обучение
### Стоян Михов
### Зимен семестър 2023/2024
#############################################################################
###
### Домашно задание 2 -- функции за семплиране на думи
###
#############################################################################

import random
import numpy as np

#############################################################
###  Случайна извадка от негативни примери --
###  избира от зададена последователност за семплиране seq
###  negativesCount на брой негативни примери различни от c.
###  Връща списък, който съдържа на първа позиция c, а на следващите
###  negativesCount позиции -- негативни примери различни от c
#############################################################
def sampleContext(c,seq,negativesCount):
    context = [c]
    while len(context) <= negativesCount:
        cn = random.choice(seq)
        if cn != c:
            context.append(cn)
    return context

#############################################################
###  Създаване на последователност за семплиране
#############################################################
def createSamplingSequence(freqs):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща списък seq, в който броят на срещанията на даден индекс на терм
    ###  е пропорционален на желаната вероятност (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда

    seq = []
    for i in range(len(freqs)):
        seq.extend([i for _ in range(round(freqs[i]**0.75))])
    seq = np.array(seq)

    #### Край на Вашия код
    #############################################################################
    return seq

#############################################################
###  Създаване на последователност за семплиране
#############################################################
def noiseDistribution(freqs,negativesCount):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща вектор q_noise, с дължина броя на думите в речника, в който 
    ###  на позиция  i стойността следва да е логаритъм от negativesCount по вероятността 
    ###  на терма с индекс i (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда

    q_noise = []
    denominator = sum([round(w_cound**0.75) for w_cound in freqs])
    for i in range(len(freqs)):
        q_noise.append(np.log(negativesCount*round(freqs[i]**0.75)/denominator))
    q_noise = np.array(q_noise)

    #### Край на Вашия код
    #############################################################################
    return q_noise
